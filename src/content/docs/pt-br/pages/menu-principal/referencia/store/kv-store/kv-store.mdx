---
title: KV Store
description: >-
  KV Store √© um servi√ßo de armazenamento de chave-valor distribu√≠do que opera 
  na rede de edge da Azion, fornecendo persist√™ncia e recupera√ß√£o de dados com 
  baixa lat√™ncia.
meta_tags: 'kv, armazenamento, chave, distribu√≠do, consultas, edge, chave-valor'
namespace: docs_kv_store
permalink: /documentacao/produtos/store/kv-store/
---

import Tag from 'primevue/tag'
import LinkButton from 'azion-webkit/linkbutton'

<Tag severity="info" client:only="vue">
  Preview
</Tag>

KV Store √© um servi√ßo de armazenamento de chave-valor distribu√≠do que opera em 
toda a rede de edge da Azion. Ele permite que voc√™ persista e recupere pequenos 
peda√ßos de dados com lat√™ncia muito baixa de qualquer lugar onde seus usu√°rios 
estejam, sem precisar gerenciar servidores.

Casos de uso t√≠picos incluem:

- Sess√µes e tokens de autentica√ß√£o
- Feature flags e configura√ß√µes de testes A/B
- Prefer√™ncias de usu√°rio e personaliza√ß√£o
- Cache de respostas de API e fragmentos computados
- Contadores de rate limit e chaves de idempot√™ncia
- Estado do carrinho de compras ou rascunho

---

## Como funciona

O KV Store organiza dados em namespaces, onde cada namespace cont√©m um conjunto 
independente de chaves. Veja como o sistema opera:

- Os dados s√£o organizados em **namespaces** que cont√™m conjuntos independentes de chaves.
- Cada item √© endere√ßado por uma **chave** que √© √∫nica dentro de seu namespace.
- Os valores podem ser armazenados como **texto**, **JSON**, **ArrayBuffer** ou **ReadableStream**.
- Os dados s√£o replicados entre os edge nodes da Azion para maximizar a disponibilidade e o desempenho de leitura.
- Opera√ß√µes de chave √∫nica s√£o at√¥micas por chave. Transa√ß√µes de m√∫ltiplas chaves n√£o s√£o suportadas.

---

## Recursos de implementa√ß√£o

| Escopo | Recurso |
| ------ | ------- |
| Gerenciar KV Store com Functions | [Como gerenciar KV Store com Functions](/pt-br/documentacao/produtos/guias/kv-store/gerenciar-com-funcoes/) |
| Refer√™ncia da API KV Store | [Azion API - KV Store](https://api.azion.com/) |

---

## Resili√™ncia de dados

O KV Store usa uma arquitetura distribu√≠da com replica√ß√£o entre os edge nodes 
da Azion. Novas grava√ß√µes s√£o aceitas no edge e propagadas para r√©plicas para 
garantir durabilidade e alta disponibilidade. Leituras s√£o servidas da r√©plica 
saud√°vel mais pr√≥xima para minimizar a lat√™ncia.

---

## Namespaces

Um namespace √© um espa√ßo de chaves isolado. Use namespaces para segmentar dados 
por aplica√ß√£o, ambiente ou carga de trabalho.

### Padr√µes recomendados

- Use namespaces separados para ambientes de produ√ß√£o e staging.
- Prefixe chaves para modelar hierarquia, por exemplo: `users/123/profile`, `flags/new-ui`, `carts/region-br/user-42`.
- Mantenha as chaves curtas e significativas; prefira alguns segmentos do tipo caminho em vez de longos identificadores opacos.

### Conven√ß√µes de nomenclatura

- Os nomes devem ser √∫nicos dentro da sua conta.
- Os nomes devem ter entre 3 e 63 caracteres.
- Use letras min√∫sculas, n√∫meros, hifens e underscores.
- Os nomes devem corresponder ao padr√£o: `^[a-zA-Z0-9_-]+$`

### Gerenciando namespaces via API

Voc√™ pode gerenciar namespaces usando a API da Azion. O endpoint base √©:

```
https://api.azion.com/v4/workspace/kv/namespaces
```

#### Criar um namespace

```bash
curl -X POST "https://api.azion.com/v4/workspace/kv/namespaces" \
  -H "Authorization: Token SEU_TOKEN_API" \
  -H "Content-Type: application/json" \
  -d '{"name": "meu-namespace"}'
```

**Resposta (201 Created):**

```json
{
  "name": "meu-namespace",
  "created_at": "2025-01-24T14:15:22Z",
  "last_modified": "2025-01-24T14:15:22Z"
}
```

#### Listar namespaces

```bash
curl -X GET "https://api.azion.com/v4/workspace/kv/namespaces" \
  -H "Authorization: Token SEU_TOKEN_API" \
  -H "Accept: application/json"
```

**Par√¢metros de consulta:**

| Par√¢metro | Tipo | Descri√ß√£o |
| --------- | ---- | --------- |
| `fields` | string | Lista separada por v√≠rgulas de nomes de campos para incluir na resposta |
| `page` | integer | N√∫mero da p√°gina dentro do conjunto de resultados paginados |
| `page_size` | integer | N√∫mero de itens por p√°gina |

#### Recuperar um namespace

```bash
curl -X GET "https://api.azion.com/v4/workspace/kv/namespaces/{namespace}" \
  -H "Authorization: Token SEU_TOKEN_API" \
  -H "Accept: application/json"
```

---

## Intera√ß√£o com KV Store via Functions

Voc√™ pode interagir com o KV Store diretamente de suas edge functions usando a 
classe `Azion.KV`. Os exemplos abaixo ilustram padr√µes comuns para criar, ler, 
atualizar e excluir dados.

### Inicializando o cliente KV

Voc√™ pode inicializar o cliente KV usando o construtor ou o m√©todo `open`:

```javascript
// Usando o namespace padr√£o
const kv = new Azion.KV();

// Usando um namespace espec√≠fico
const kv = new Azion.KV("meu-namespace");

// Usando o m√©todo open
const kv = await Azion.KV.open("meu-namespace");
```

### Armazenando dados (put)

Armazene valores em diferentes formatos:

```javascript
async function handleRequest(request) {
    const kv = new Azion.KV();
    const key = "sessao-usuario";

    // Armazenar um valor string
    await kv.put(key, "dados-da-sessao-aqui");

    // Armazenar um objeto JSON
    await kv.put(key, { userId: 123, role: "admin" });

    // Armazenar um ArrayBuffer
    const encoder = new TextEncoder();
    const buffer = encoder.encode("dados bin√°rios").buffer;
    await kv.put(key, buffer);

    // Armazenar com op√ß√µes (metadados e expira√ß√£o)
    await kv.put(key, "valor", {
        metadata: { created_by: "user-42" },
        expiration: Math.floor(Date.now() / 1000) + 3600, // expira em 1 hora
        expirationTtl: 3600 // alternativa: TTL em segundos
    });

    return new Response("Dados armazenados", { status: 200 });
}

addEventListener("fetch", (event) => {
    event.respondWith(handleRequest(event.request));
});
```

### Armazenando dados grandes com streams

Para payloads grandes, use `ReadableStream` para transmitir dados de forma eficiente:

```javascript
async function handleRequest(request) {
    const kv = new Azion.KV();
    const key = "arquivo-grande";
    const dataSizeInKB = 500;
    const totalSize = dataSizeInKB * 1024;
    const chunkSize = 64 * 1024; // chunks de 64KB

    const stream = new ReadableStream({
        async start(controller) {
            const encoder = new TextEncoder();
            const numChunks = Math.ceil(totalSize / chunkSize);

            for (let i = 0; i < numChunks; i++) {
                const currentChunkSize = Math.min(chunkSize, totalSize - i * chunkSize);
                const chunk = "a".repeat(currentChunkSize);
                controller.enqueue(encoder.encode(chunk));
            }
            controller.close();
        },
    });

    await kv.put(key, stream);

    return new Response("Dados grandes armazenados", { status: 200 });
}

addEventListener("fetch", (event) => {
    event.respondWith(handleRequest(event.request));
});
```

### Recuperando dados (get)

Recupere valores em diferentes formatos:

```javascript
async function handleRequest(request) {
    const kv = new Azion.KV();
    const key = "sessao-usuario";

    // Obter como texto (padr√£o)
    const textValue = await kv.get(key, "text");

    // Obter como JSON
    const jsonValue = await kv.get(key, "json");
    console.log(`User ID: ${jsonValue.userId}`);

    // Obter como ArrayBuffer
    const bufferValue = await kv.get(key, "arrayBuffer");
    const decoder = new TextDecoder("utf-8");
    const decodedString = decoder.decode(bufferValue);

    // Obter como ReadableStream
    const streamValue = await kv.get(key, "stream");

    // Tratar chaves inexistentes (retorna null)
    const missing = await kv.get("chave-inexistente", "text");
    if (missing === null) {
        console.log("Chave n√£o encontrada");
    }

    return new Response(textValue, { status: 200 });
}

addEventListener("fetch", (event) => {
    event.respondWith(handleRequest(event.request));
});
```

### Recuperando m√∫ltiplas chaves

Recupere m√∫ltiplos valores em uma √∫nica opera√ß√£o:

```javascript
async function handleRequest(request) {
    const kv = new Azion.KV();

    const keys = ["usuario-1", "usuario-2", "usuario-3"];
    const data = await kv.get(keys, "text");

    // Retorna um objeto com pares chave-valor
    // Chaves inexistentes t√™m valores null
    console.log(JSON.stringify(data));

    return new Response(JSON.stringify(data), {
        headers: { "Content-Type": "application/json" },
        status: 200,
    });
}

addEventListener("fetch", (event) => {
    event.respondWith(handleRequest(event.request));
});
```

### Recuperando dados com metadados

Use `getWithMetadata` para recuperar tanto o valor quanto seus metadados associados:

```javascript
async function handleRequest(request) {
    const kv = new Azion.KV();
    const key = "sessao-usuario";

    // Armazenar com metadados
    await kv.put(key, "valor-sessao", {
        metadata: { created_by: "user-42", version: 1 }
    });

    // Recuperar com metadados
    const data = await kv.getWithMetadata(key, "text");
    console.log(`Valor: ${data.value}`);
    console.log(`Metadados: ${JSON.stringify(data.metadata)}`);

    // Funciona com m√∫ltiplas chaves tamb√©m
    const keys = ["chave1", "chave2"];
    const multiData = await kv.getWithMetadata(keys, "text");

    return new Response(JSON.stringify(data), {
        headers: { "Content-Type": "application/json" },
        status: 200,
    });
}

addEventListener("fetch", (event) => {
    event.respondWith(handleRequest(event.request));
});
```

### Lendo streams

Processe dados em stream de forma incremental:

```javascript
async function handleRequest(request) {
    const kv = new Azion.KV();
    const key = "arquivo-grande";

    const stream = await kv.get(key, "stream");

    if (stream instanceof ReadableStream) {
        const decoder = new TextDecoder();
        let text = "";

        for await (const chunk of stream) {
            text += decoder.decode(chunk, { stream: true });
        }
        text += decoder.decode();

        console.log(`Recuperados ${text.length} caracteres`);
    }

    // Ou retorne o stream diretamente na resposta
    return new Response(stream);
}

addEventListener("fetch", (event) => {
    event.respondWith(handleRequest(event.request));
});
```

### Excluindo dados

Remova uma chave do armazenamento:

```javascript
async function handleRequest(request) {
    const kv = new Azion.KV();
    const key = "sessao-usuario";

    await kv.delete(key);

    return new Response("Chave exclu√≠da", { status: 200 });
}

addEventListener("fetch", (event) => {
    event.respondWith(handleRequest(event.request));
});
```

### Trabalhando com Unicode e caracteres especiais

O KV Store suporta chaves e valores codificados em UTF-8 e UTF-16:

```javascript
async function handleRequest(request) {
    const kv = new Azion.KV();

    // Chave UTF-16 (Chin√™s: "Minha Chave")
    const key = "ÊàëÁöÑÈí•Âåô";

    // Valor UTF-16 com emojis
    const value = "üåçüåéüåè Hello World ‰Ω†Â•Ω ‰∏ñÁïå";

    await kv.put(key, value);

    const retrieved = await kv.get(key, "text");
    console.log(`Chave: ${key}, Valor: ${retrieved}`);

    return new Response("OK", { status: 200 });
}

addEventListener("fetch", (event) => {
    event.respondWith(handleRequest(event.request));
});
```

### Excluindo namespaces

Exclua um namespace inteiro programaticamente:

```javascript
async function handleRequest(request) {
    const namespaceName = "meu-namespace";

    // Excluir o namespace
    await Azion.KV.delete(namespaceName);

    return new Response("Namespace exclu√≠do", { status: 200 });
}

addEventListener("fetch", (event) => {
    event.respondWith(handleRequest(event.request));
});
```

---

## Refer√™ncia de m√©todos

A classe `Azion.KV` fornece os seguintes m√©todos:

### Construtor e inicializa√ß√£o

| M√©todo | Descri√ß√£o |
| ------ | --------- |
| `new Azion.KV()` | Cria uma inst√¢ncia KV usando o namespace padr√£o |
| `new Azion.KV(name)` | Cria uma inst√¢ncia KV para o namespace especificado |
| `Azion.KV.open(name)` | Abre um namespace de forma ass√≠ncrona |
| `Azion.KV.delete(name)` | Exclui um namespace |

### Opera√ß√µes de dados

| M√©todo | Par√¢metros | Retorna | Descri√ß√£o |
| ------ | ---------- | ------- | --------- |
| `put(key, value, options?)` | `key`: string<br>`value`: string \| object \| ArrayBuffer \| ReadableStream<br>`options`: { metadata?, expiration?, expirationTtl? } | `Promise<void>` | Armazena um valor |
| `get(key, type?)` | `key`: string \| string[]<br>`type`: "text" \| "json" \| "arrayBuffer" \| "stream" | `Promise<value \| null>` | Recupera um valor |
| `getWithMetadata(key, type?)` | `key`: string \| string[]<br>`type`: "text" \| "json" \| "arrayBuffer" \| "stream" | `Promise<{value, metadata}>` | Recupera valor com metadados |
| `delete(key)` | `key`: string | `Promise<void>` | Exclui uma chave |

### Op√ß√µes do put

| Op√ß√£o | Tipo | Descri√ß√£o |
| ----- | ---- | --------- |
| `metadata` | object | Metadados personalizados para associar √† chave (m√°x 1024 bytes JSON-serializado) |
| `expiration` | number | Timestamp Unix (segundos) quando a chave expira |
| `expirationTtl` | number | Time-to-live em segundos a partir de agora |

### Tipos do get

| Tipo | Retorna | Descri√ß√£o |
| ---- | ------- | --------- |
| `"text"` | string | Retorna o valor como uma string UTF-8 (padr√£o) |
| `"json"` | object | Faz parse do valor como JSON |
| `"arrayBuffer"` | ArrayBuffer | Retorna dados bin√°rios brutos |
| `"stream"` | ReadableStream | Retorna um stream leg√≠vel para valores grandes |

---

## Limites

Estes s√£o os **limites padr√£o**:

| Limite | Valor |
| ------ | ----- |
| Taxa de grava√ß√£o por chave | At√© 1 grava√ß√£o por segundo para a mesma chave |
| Tamanho da chave | At√© 512 bytes (UTF-8) |
| Tamanho dos metadados | At√© 1024 bytes (JSON-serializado) |
| Tamanho do valor | At√© 25 MB por item |
| Comprimento do nome do namespace | 3-63 caracteres |

Estes s√£o os **limites padr√£o** para cada Plano de Servi√ßo:

| Escopo | Developer | Business | Enterprise | Mission Critical |
| ------ | --------- | -------- | ---------- | ---------------- |
| Namespaces | 10 | 50 | 200 | 200 |
| Tamanho m√°ximo do arquivo | 200 MB | 500 MB | 2 GB | 2 GB |
| Armazenamento m√°ximo por conta | 5 GB | 50 GB | 300 GB | 300 GB |

---
