---
title: Features GraphQL API
description: GraphQL features consist of datasets, filtering, sorting, and pagination. The features provide easy access to your data, and using and combining the available features creates more personalized and specific queries to request the exact information you need.
meta_tags: graphql, api, azion, query, features
namespace: documentation_graphql_features
permalink: documentation/products/graphql-api-features/
menu_namespace: graphqlMenu
---

import Button from '~/components/Button.astro'

**GraphQL** features consist of **datasets**, **filtering**, **sorting**, and **pagination**. The features provide easy access to your data, and using and combining the available features creates more personalized and specific queries to request the exact information you need.

The next sections will detail each available feature of GraphQL and how to use them.

---

## Datasets

Azion **GraphQL API** uses defined datasets to indicate what requests you can run through queries and fetches data from **Real-Time Metrics** and **Real-Time Events**. They consist of organized tables informing your data.

Find each available dataset and what they request next.

### Real-Time Metrics GraphQL API

| Dataset | Description |
| ------- | ----------- |
| dataStreamedMetrics | Sent events of data by [Data Streaming](/en/documentation/products/data-streaming/) to the clients' endpoint. |
| edgeFunctionsMetrics | Events executed by [Edge Functions](/en/documentation/products/edge-application/edge-functions/). |
| httpMetrics | Request events registered by [Edge Application](/en/documentation/products/edge-application/) and [Edge Firewall](/en/documentation/products/edge-firewall/). |
| idnsQueriesMetrics | Query events performed on [Intelligent DNS](/en/documentation/products/intelligent-dns/). |
| imagesProcessedMetrics | Image processing events by [Image Processor](/en/documentation/products/edge-application/image-processor/). |
| l2CacheMetrics | Request events registered by [L2 Caching](/en/documentation/products/edge-application/l2-caching/). |

<Button href="/en/documentation/products/graphql-api/features/metrics-fields/" text="see Fields Real-Time Metrics GraphQL API descriptions" variant="secondary"></Button>

### Real-Time Events GraphQL API

| Dataset | Description |
| ------- | ----------- |
| activityHistoryEvents | Events logs from an account on Real-Time Manager (RTM) regarding activities registered on [Activity History](/en/documentation/products/accounts/activity-history/). |
| cellsConsoleEvents |  Events logs from applications using [Edge Runtime](/en/documentation/products/edge-application/edge-functions/runtime/overview/) returned by the Cells Console. |
| dataStreamedEvents | Sent events of data by [Data Streaming](/en/documentation/products/data-streaming/) to the clients' endpoint. |
| edgeFunctionsEvents | Events executed by [Edge Functions](/en/documentation/products/edge-application/edge-functions/). |
| httpEvents | Request events registered by [Edge Application](/en/documentation/products/edge-application/) and [Edge Firewall](/en/documentation/products/edge-firewall/). |
| idnsQueriesEvents | Query events performed on [Intelligent DNS](/en/documentation/products/intelligent-dns/). |
| imagesProcessedEvents |  Image processing events by [Image Processor](/en/documentation/products/edge-application/image-processor/). |
| l2CacheEvents | Request events registered by [L2 Caching](/en/documentation/products/edge-application/l2-caching/). |

---

:::tip
You can also run an **Introspection Query** to consult metadata on the Metrics and Events datasets. Metadata provide what each dataset of the GraphQL APIs supports and specific information: name, description, and format. Find out more on the [How to query metadata with GraphQL API](/en/documentation/products/guides/graphql-metadata/) guide.
:::

You can request both the *raw* model, using the **Events** datasets, and the *aggregated* model, using the **Metrics** datasets.

<Button href="/en/documentation/products/graphql-api-queries/#raw-data" text="go to raw queries reference" variant="secondary"></Button> <br></br>

<Button href="/en/documentation/products/graphql-api-queries/#aggregated-data" text="go to aggregated queries reference" variant="secondary"></Button> <br></br>

<Button href="/en/documentation/products/guides/graphql-aggregated-data/" text="go to How to query aggregated data guide" variant="secondary"></Button>

---

## Filtering

With filtering parameters, responses returned by your queries can be more accurate to your set of data. You can use filtering with any available field in the dataset you're consulting.

As requesting complex or a large amount of data can cause responses to get noisy and complicate its use, filtering queries helps with getting exact and direct data from your requests. For example, if you're using the following query to request `httpMetrics`:

```graphql
query HttpQuery {
  httpMetrics(
    limit: 10
    filter: {
      tsRange: {begin:"2022-10-20T10:10:10", end:"2022-10-23T10:10:10"}
    }
  ) 
  {	
    ts
    sourceLocPop
  }
}
```

You can filter the query by requesting data specific to the `sourceLocPop` field:

```graphql
query HttpQuery {
  httpMetrics(
    limit: 10
    filter: {
      tsRange: {begin:"2022-10-20T10:10:10", end:"2022-10-23T10:10:10"}
      sourceLocPop: "lax-bso"
    }
  ) 
  {	
    ts
    sourceLocPop
  }
}
```

You can feel free to update your request to use a field of your interest within the fields of the dataset you're consulting.

You can also filter using multiple `AND` and `OR` parameters. Make sure you define all the fields you're filtering for inside the parameter, like in the following example:

```graphql
query totalImagesProcessedRequests {
  imagesProcessedMetrics(
    aggregate: {sum: requests}
    limit: 100
    filter: {
      tsRange: {begin:"2023-03-20T19:52:00", end:"2023-03-20T20:52:00"}
      or: {
          status:304
          statusRange: {begin: 200, end: 299}
      }
    }
    groupBy:[ts]
    orderBy:[ts_ASC]
  )
  {
    ts
    sum
  }
}
```

---

## Sorting 

The sorting feature lets you organize and sort the received data of a dataset according to the event's order. For example, if you're receiving the `host` field data as a response to your API request, you can sort the data to receive it in:

- An *ascending order (ASC)*
- A *descending order (DESC)*

Whenever you use the `orderBy` property, you must add either the `ASC` or the `DESC` specification.

For example, to use the ascending order sorting feature, you need to add `orderBy` in your query and the field you want to sort + `ASC`:

```graphql
{
    orderBy: [host_ASC]
}
```

To sort the data according to a *descending order (DESC)*, you need to add the field you want to sort + `DESC`:

```graphql
{
    orderBy: [ts_DESC]
}
```

Say you're using this query with `DESC`:

```graphql
query SumBytesSentByHost {
  httpMetrics(
    limit: 1000
    filter: {
      tsRange: {begin:"2023-01-01T17:03:00", end:"2023-06-01T18:05:00"}
    }
    aggregate: {sum: bytesSent}
    groupBy: [host]
    orderBy: [sum_DESC]
  ) 
  {        
    host
    sum
  }
}
```

You'll get a response similar to this:

```graphql
{
    "data": {
        "httpMetrics": [
            {
                "host": "g1sdetynmxe0ao.map.azionedge.net",
                "sum": 606226
            },
            {
                "host": "uaykhefjdk9or.map.azionedge.net",
                "sum": 583059
            },
            {
                "host": "wz0ywpod397zk.map.azionedge.net",
                "sum": 567633
            },
            {
                "host": "zi1435nbhec7.map.azionedge.net",
                "sum": 96002
            }
        ]
    }
}
```

And if you're using this query with `ASC`:

```graphql
query AvgRequesTimeByHost {
  httpMetrics(
    limit: 1000
    filter: {
      tsRange: {begin:"2023-01-01T17:03:00", end:"2023-06-01T18:05:00"}
    }
    aggregate: {avg:requestTime}
    groupBy: [ts, host]
    orderBy: [avg_ASC]
  ) 
  {        
    ts
    host
    avg
  }
}
```

You'll get a response similar to this:

```graphql
{
    "data": {
        "httpMetrics": [
            {
                "ts": "2023-04-21T00:00:00Z",
                "host": "zipo145nbhc7.map.azionedge.net",
                "avg": 0.04871428571428572
            },
            {
                "ts": "2023-04-13T00:00:00Z",
                "host": "g1snmxepa0ao.map.azionedge.net",
                "avg": 0.561
            },
            {
                "ts": "2023-04-11T00:00:00Z",
                "host": "g1syinmxe2ao.map.azionedge.net",
                "avg": 4.101833333333333
            },
            {
                "ts": "2023-04-11T00:00:00Z",
                "host": "wz1yd307zk.map.azionedge.net",
                "avg": 8.705666666666668
            },
            {
                "ts": "2023-05-22T00:00:00Z",
                "host": "uaifjdk6or.map.azionedge.net",
                "avg": 31.493818181818185
            }
        ]
    }
}
```

---

## Pagination

**Pagination** is a feature designed to help you decide where you want your results to begin from and how many results you want to see. Currently, Azion **GraphQL API** uses *offset and limit pagination* to provide the feature.

Using pagination can be useful when you get a large number of data in response to your API request. You can use the feature by setting **offsets** and **limits**. This way, the API knows it needs to return data within the specific range you've set.

The **offsets** parameter sets the number of records you want to skip in your data response, and the **limits** parameter sets the number of results you want to receive.

> Setting offset and limit parameters isn't mandatory. In case you don't set the parameters, GraphQL API automatically sets the **offset** for **0** and the **limit** for **10**.

See the following example on how to set offset and limit parameters:

```graphql
query HttpQuery {
  httpMetrics(
    offset: 15
    limit: 30
    filter: {
      tsRange: {begin:"2022-10-20T10:10:10", end:"2022-10-23T10:10:10"}
    }
  ) 
  {	
    ts
    sourceLocPop
  }
}
```

The offset is set for 15, meaning your response will start with the 16th result, and the limit is set for 30, meaning your response will give you a total of 30 results. In this case, you'll receive a response from the 16th result until the 45th result.

> If your data is constantly updated, using pagination may cause missing or duplicate data when you run more than one request using the feature.
